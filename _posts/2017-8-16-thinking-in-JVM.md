---
layout: post
title: 《深入理解Java虚拟机》-读书笔记
date: 2017-8-20 14:00
categories: JVM
tags: [Java,JVM]
---

* content
{:toc} 
咳咳.. 虽然对这本书有点阴影。（这是第一次面试时候的故事了）。。

但，最近翻了一下，发现.. 这本书写得真的非常好。。之前之所以看不下去，可能是自己的基础还不够。

嗯，今天挖个坑.. 我要开始看这本书了，开学之前看完。加油。

还有，JVM根本就不算Java高级特性.. 有些人一面的第一个问题就是JVM。所以，不算加分点，而是基础。

第一部分走进Java就不看了。

第二部分 自动内存管理机制

# Java内存区域和内存溢出异常

## 概述

Java把内存控制的权利交给了JVM，所以程序员不需要资源回收的情况。

但是，正是因为这种舒适区，一旦出现内存泄露和溢出方面的问题，如果不了解JVM是怎样使用内存的，那么排查错误将会成为一件非常艰难的工作。

## 运行时的数据区域

![](http://img.blog.csdn.net/20160422164641652)

### 程序计数器（PC）

是一块较小的内存空间，可以看做是当前线程锁执行字节码的 **行号指示器**

字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、判断、跳转、异常处理等都需要依赖这个计数器来完成。

特性：

- 当前线程所执行的字节码 行号指示器。
- 每个线程都有一个
- 线程私有，生命周期与线程相同，随JVM启动而生，JVM关闭而死
- 如果执行的是Native方法，那么这个计数器的值则为空（Undefined）
- 这是Java中唯一一个没有规定OutOfMemoryError情况的区域

### Java虚拟机 **栈**

主要存放的是：局部变量表、操作数栈、动态链接、方法出口等信息。

局部变量表主要包括：**基本数据类型**、**对象引用**  

（64位长度的long和double会占两个局部变量空间（Slot），其它都是占一个）

局部变量表所需的内存空间在编译期间完成分配，空间大小是确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常情况：1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；2、如果虚拟机栈可以动态扩展，如果扩展时无法申请足够的内存，就会抛出OutOfMemoryError异常。

### 本地方法栈

作用与Java虚拟机栈相似，区别在于：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的**Native方法**服务。（Native方法是指通过其他语言实现的方法，但也能在JVM上编译实现）

### 堆

Heap，是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。

主要是为了**存放对象实例**，几乎所有对象实例都在这里分配内存。（随着技术的发展，现在也不是所有对象实例都需要在堆上分配内存了。）

Java堆是垃圾回收器管理的主要区域，因此很多时候又被称作“GC堆”.. Garbage Collected Heap.. 垃圾收集堆(垃圾堆，哈哈哈)

Java堆可以在物理上不连续的内存空间中，只要逻辑上是连续的即可。

关于异常：如果在堆中没有完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

### 方法区

Method Area，与Java堆一样，是各个线程共享的内存区域。

存储已被虚拟机加载的**类信息、常量、静态变量**等。

它有个别名叫 Non - Heap（非堆），目的是和堆区分开来。

关于异常：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

### 运行时常量池

Runtime Constant Pool 是方法区的一部分。

主要跟Class文件有关。Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项重要的信息叫做常量池（Constant Pool Table），用于**存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。

具有动态性，也就是说并不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入池中。这种特性的话，主要就是String类的intern()方法。

关于异常，既然它属于方法区，所以当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

### 直接内存

Direct Memory 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但用的非常多，并且也可能产生OutOfMemoryError异常。

书上主要讲了Java1.4里面的NIO（New I/O），里面引入了一种基于通道和穿冲去的I/O方式：可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能明显的提高性能，因为它避免了在Java堆和Native堆中来回复制数据。

本机分配的直接内存不受Java堆大小的限制，但受机器总内存的影响。在动态扩展时还是有可能会出现OutOfMemoryError异常。























