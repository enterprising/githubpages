---
layout: post
title: 《Java并发编程实战》-读书笔记（持续更新）
date: 2017-8-18 22:00
categories: Java
tags: [Java,多线程,并发]
---

* content
{:toc} 
写在前面：

暑假最后三个坑：《深入理解Java虚拟机》、《Java并发编程实战》、《剑指offer》。

Java并发编程实战这本书，在昨天（17.8.17）晚上翻了一下，发现里面很多知识点其实我已经在项目里用到过了。嗯，说明是时候看这本书了。这是Java高级技术了，暑假结束之前看完。

加油。

# 第一章 简介

首先你要知道啥是并发

![](https://ws1.sinaimg.cn/large/006tKfTcgy1fi6t2imncdj30go0cj752.jpg)

Concurrent。并发。

我的理解，就是使用多线程.. 当一个线程在使用CPU资源结束，然后在使用IO。这时候CPU空闲，我们就能让其它线程去使用CPU了。类似这种机制就叫并发。

现实中有很多事都是并发的，比如，当你烧水的时候，你可以选择打把农药。嗯，烧水喝打农药这两件事就是并发的。

# 第二章 线程安全性

##定义

线程安全性的定义：当多个线程访问某个类或者某个变量的时候，这个类始终都能表现成正确的行为，那么就称这个类是线程安全的。

一个对象是否需要线程安全，取决于它是否被多个线程访问。要使得线程，那么需要**同步机制**来协同对对象的访问。

Java中的主要同步机制是：关键字synchronized（加锁方式是独占锁）、volatile类型的变量、显式锁（Explicit Lock）以及原子变量。

无状态对象：既不包含任何域，也不包含任何对其他类中域的引用。由于线程访问无状态对象的行为并不会影响其它线程中操作的正确性，因此，**所有的无状态对象都是线程安全的**。

## 原子性

这一小节举了个例子： i++；

虽然看上去没毛病，好像是线程安全的。但是 i++ 分为了三步：读取-修改-写入，并且其结果状态依赖于之前的状态（ps：volatile不适用这种情况）。

所以，它不满足原子性。

在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有个正式的名字：竞态条件（Race Condition）。

### 竞态条件

简单的说的话，大概就是.. 你和你女朋友约定在星巴克见面，但是那块地方有两个星巴克（A和B），你在A的时候她在B，然后你去找她的同时她也来这找你.. 嗯，类似死锁。

最常见的竞态条件类型是：先检查后执行，即**通过一个可能失效的观测结果来决定下一步的动作**。

### 延迟初始化

这是 竞态条件 最常见的一种体现。

直接贴代码：

```java
public class LazyInitRace{
    private xxx instance = null;
  	
 	public xxx getInstance(){
        if(instance == null)
          instance = new xxx();
      	return instance;
    }
}
```

。。一般很多人会写这种的代码。看上去没啥毛病，其实里面有竞态条件。嗯，设计模式的单例模式里面有批判了这种实现。

为啥说有问题呢？因为.. 假定线程A和线程B同时执行getInstance()，A看到instance是空的，就创建了一个。。但.. 线程B就不一定直到它是空了，为啥呢？因为A实例化一个instance需要很长时间，可能B检查的时候发现是空，但其实这时候A已经在创建了只是还没建好。。嗯，然后就尴尬了。

这就是最常见的一种竞态条件：延迟初始化。

### 复合操作

简单的说，上面那些情况的出现主要是少了原子性。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其它线程使用这个变量，从而确保其它线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改过程中间。

原子操作是指以原子的方式执行的操作.. （这句是废话）

安利Java5的java.concurrent包，这个包主要是用于并发的。然后里面有个atomic包，主要是负责原子性的。

使用demo：

> private AtomicLong count = new AtomicLong(0);

基本上符合原子性的操作或者类，大多数都是线程安全的。

## 加锁机制

### 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）

线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。获得内置锁（Intrinsic Lock）的唯一途径就是进入由这个锁保护的同步代码块或方法。（这句话可能翻译的有点问题）

Java的内置锁相当于一种互斥锁，啥是互斥锁呢，大概就是最多只有一个线程能用持有这种锁。当线程A尝试获取一个由线程B持有的锁是，线程A必须等待或者阻塞，直到线程B释放这个锁。如果B不释放这个锁，A就会永远等下去。。嗯，这就是互斥锁.. 当出现等不到的情况，那就是死锁。

由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块会以原子的方式执行。

### 重入

之前对重入概念的理解好像有点点错误。

最关键的一句话：**”重入“意味着获取锁的操作的粒度是“线程”，而不是“调用”。**

怎么理解呢？当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被则塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个线程就会请求成功。

其实，当时的理解好像也没完全错。在一个同步方法里面调用另一个方法会成功，因为是同一个线程。

## 用锁来保护状态

锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。

过时的集合类Vector还有好多其它同步集合类都是用的这种模式。

还有一点，虽然synchronized方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要其它的加锁机制。

此外，将每个方法都作为同步方法，这样不太好，因为会造成活跃性问题和性能问题。线程安全必然会造成性能的下降，开销的增加。

## 性能和活跃性

Performance and Liveness。

当使用锁是，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果持有锁的时间过程，那么都会带来活跃性或性能问题。

书上的建议是：当执行时间较长的计算或者可能无法快速完成的操作（例如，网络IO或控制台IO），一定不要持有锁。

<br/>

# 第三章 对象的共享

未完待续.. 我快饿死了，吃饭去了。下午看《深入理解Java虚拟机》。