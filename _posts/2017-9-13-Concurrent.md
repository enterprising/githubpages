---
layout: post
title: 并发
date: 2017-9-13 10:00
categories: Java
tags: [Java]
---

* content
{:toc} 
内容整理自《Java编程思想》第四版，第21章 并发

java.util.concurrent包

我的理解，主要就是多线程。

# 并发的多面性

用并发解决的问题大体上可以分为两种：“速度” 和 “设计可管理性”

## 更快的执行

并发是利用多处理器编程的基本工具。

并发通常是提高运行在单处理器上的程序的性能。

上面这句话听起来可能违背直觉，但其实并不是。因为这样可以节省上下文切换（从一个任务切换到另外一个任务）的代价。

这里面还需要考虑的是阻塞的问题，当一个任务被阻塞了，程序中的其它任务理论上应该是可以继续执行的才对。

在单处理器系统中的性能提高的常见示例是：事件驱动的编程。

## 改进代码设计

这里面提到了，并发的主要应用场景是游戏的地图、场景等刷新。还有就是用户窗口程序等。

并发是需要代价的，包含复杂性代价。但跟它收获的好处相比，这点代价显得微不足道。

通常，线程使你能够创建更加松耦合的设计（我的理解是，每个任务是一个线程）

# 基本的线程机制

并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务中的每一个都将由执行线程来驱动。

一个线程就是子安进程中的一个单一的顺序控制流。

## 定义任务

线程可以驱动任务，因此你需要一种描述任务的方式。Runnable接口，重写里面的 run 方法。

要实现线程行为，你必须显式地将一个任务附着到线程上。

## Thread类

这里面主要讲了两种东西：

继承Thread类，然后重写里面的run方法。

构造Thread类的时候，传进去一个Runnable对象。

最后再调用Thread的start方法。这样就开启一个线程了。

## 使用Executor

这是java.util.concurrent包里面的 执行器。

这个东西主要就是帮你管理Thread对象，从而简化了并发编程。

Executor在客户端和任务执行之间提供了一个间接层，与客户端直接执行任务不同，这个中介对象将执行任务。相当于代理模式吧，我觉得。

里面的线程是异步执行的。

## 从任务中产生返回值

Runnable是执行工作的独立任务，但是它不反悔任何值。

当你希望任务在完成时能够返回一个值的时候，那么你可以选择Callable接口来代替Runnable接口。重写里面的call方法。

接收的话是用：Future<xxx> f = pool.submit(这里是Callable对象);

上面的 pool 是：ExecutorService pool = Executor.newFixedThreadPoll(xx); //当然也可以是其它线程池

最后使用 f.get(); 方法，接收。

## 休眠

sleep(); 这将使任务中止给定的时间。这会阻塞线程

yield(); 中止，但不阻塞线程，线程变回runable状态。

## 优先级

Thread线程

读取优先级：getPriority();

修改优先级：setPriority();

## 让步

yield();

## 后台线程(守护线程)

所谓的后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。

我的理解，这TM就是守护线程好吗

## 加入一个线程

一个线程可以在其他线程之上调用 join() 方法，其效果是等待一段时间直到第二个线程结束才继续执行。

如果某个线程在另一个线程 t 上调用 t.join() ，此线程将被挂起，直到目标线程 t 结束之后才恢复。（即t.isAlive()返回false）

# 共享受限资源

既然讲到多线程，那么肯定会涉及到资源共享的问题。我的理解，这部分主要就是讲线程安全那些东西了。

## 不正确地访问资源

.. 主要就是多线程访问某个共享资源，这可能会出现脏读等现象。

## 解决共享资源竞争

防止访问冲突的方法就是：当资源被一个任务使用时，对其进行加锁。第一个访问某项资源的任务必须锁定这项资源，使其它任务在其被解锁之前，无法访问它。

基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方式。这意味着每次只能有一个线程访问资源。其实主要就是加锁。因为锁语句产生了一种互相排斥的效果，所以这种机制常常被称为互斥量（mutex）。

