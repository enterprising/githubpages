---
layout: post
title: JVM类加载机制
date: 2017-8-26 21:00
categories: JVM
tags: [JVM]
---

* content
{:toc} 
# 概述

Class文件中描述的各种信息，最终都需要加载到JVM中之后才能运行和使用。这一章主要讲的是JVM如何加载这些Class文件，以及Class文件中的信息进入到JVM中之后会发生一些啥变化。

简单的说就是：**JVM把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型。**这就是JVM的类加载机制。

在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。这也是它的一大特点：运行期动态加载和动态连接。

# 类加载的生命周期和时机

从加载进JVM内存到卸载出JVM内存，主要的生命周期包括：加载、验证、准备、解析、初始化、使用、卸载。

其中（验证，准备，解析）这三部分统称为连接。

那什么时候加载呢？这个没有强制约束，可以交给JVM自己把握。

关于初始化就有要求了：

- 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，会触发初始化；
- 使用java.lang.reflect包中的方法对类进行反射调用时，如果类没有进行初始化，那么需要先触发使其初始化；
- 当初始化一个类的时候，如果发现其父类还没有初始化，那么先初始化它的父类；
- 当虚拟机启动时，用户需要指定一个主类（含main方法的类），JVM会先初始化这个主类；
- 当使用Java7动态语言支持时；

# 类加载的过程

加载、验证、准备、解析、初始化

## 加载

加载只是类加载的一个阶段。

在这个阶段JVM主要做三件事：

- 通过类的全限定名来获取定义此类的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

这里有个考点，相对于类加载的其它阶段，一个非数组类的加载阶段是开发人员可控性最强的（可以用系统提供的引导类加载器也可以自定义类加载器）。所谓的自定义类加载器主要是重写一个类加载器的loadClass方法。

但数组类不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。和类加载器的关系的话，数组类里的元素类型需要靠类加载器创建。

加载阶段完成之后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中。

加载阶段与连接阶段的部分内容是交叉进行的，但开始时间还是保持着先后顺序。

# 验证

目的是为了确保Class文件的字节流中包含的信息符合当前JVM的要求，并且不会危害JVM自身的安全。

未完待续.. 吃饭了