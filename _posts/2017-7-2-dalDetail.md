---
layout: post
title: DAL架构的一些细节
date: 2017-7-2 11:50
categories: DAL
tags: [DAL]
---

DAL主要有以下几部分组成：

## 1、配置

包括zookeeper和job

## 2、协议

这部分主要包括TCP的协议、MySQL的协议、PG的协议

## 3、状态机

SQLSessionContext类里面的几种状态。处理每个连接上的所有请求。  

状态机是整个DAL里面非常核心的一部分。主要包括Analyze、handle、result、quit等。

![状态机](https://ws3.sinaimg.cn/large/006tKfTcly1fh5epo6g05j30cu0hijrr.jpg)

## 4、语法解析

就是讲一个SQL语句解析成语法树，这里使用的是阿里提供的Druid。

## 5、流控--保护数据库

讲客户端的请求分成两个队列，一个叫做《事务队列》，主要负责数据的增删改等。另一个叫做《查询队列》，主要负责SELECE语句。

## 6、连接池

针对于每个数据库都有一个pool

分层：

  顶层：org业务

下面有三层结构，成网状分布

dal group 相当于DAL给用户的DB，组合了多个db group。

db group 分为 master和slave，前者主要为了写数据，后者主要是为了读数据。

pool 针对一个DB有多个连接，可能有多个db group在用一个pool

## 7、心跳

DAL连着很多数据库

心跳主要是为了检测连接是否可用，这种连接和之前说的那种普通的连接不同，是一种特殊的连接。用于检测连接是否可用，只能发送简单的指令，比如 select 1;

## 8、global id

相当于主键，但又不是主键。是一个很长很长的用于标识数据唯一性的一个标识。这里面又包含一维分表和二维分表的概念了。

要了解这个首先我们需要了解什么是分片为什么要分片，因为数据量特别特别大，要查找起来就会十分慢，就算有索引也慢。所以才有了分片的出现。分片主要是分了将数据分开存储，乍一看会觉得这是多此一举，但是在吞吐量十分巨大的时候这是非常有必要的。暂时不考虑分库，分表的话主要是用了hash规则，sharding，把数据按照某一列hash后的值，分配到不同的表。在查的时候再反hash一次，就能找到是在哪个表里面了。因为每个表里面是数据量都不会很大，所以这时候查找起来就会方便很多，速度也会快很多。

二维分表

举个例子，订单表  id uid rid 是一个中间表，有时候可能会按照uid来找，有时候又有可能会按照rid来找。这时候就需要二维sharding了，我们DAL的思路是 把uid和rid嵌入到global id里面。seed 在所有的数据库中表示唯一的数据。seed uid rid整个就相当于global id 能唯一标示这个数据项。所谓的二维其实就是，按照uid Sharding一次之后存储，然后又按照rid Sharding一次之后存储，简单的说就是存了两份数据。这样浪费了一部分存储空间，但是换来的是查询速度增快，再加上公司现在有15000多台机器，所以这点代价还是值得的。

## 9、batch （批处理）

用于支持多值，批量操作。比如：

insert into tablename(xx,xx) values(xx,xx),(xx,xx),(xx,xx); 这条SQL语句表示同时处理多个值。batch就是为了处理这种情况。

## 10、不间断升级

reuseport(一个特殊的端口)

DAL（老的）DAL（新的）

我们要做的就是用新的DAL替代老的DAL，但是因为老的DAL每时每刻都有很多流量进去，要关闭替换的话必定会造成很大的影响。在Unix系统中，一般一个端口只对应一个进程。但是有一个特殊的端口，这个端口能够被多个进程同事访问。这就是我们做不间断升级的关键点。

具体实现思路：先启动新的DAL，绑定到端口上。老进程，关掉端口（为了拒绝新来的连接，但老的还是保留，设定一个最大时间 超时则断开连接，将损失降到最低）但这个进程并不退出。设定一个timeout，超时则退出。这样我们的损失就能降到最低，实现不间断升级。

## 11、端口管理

DAL里主要处理了两种数据库，一种是MySQL，我们对于的DAL端口是9803，还一种数据库是PG，端口是7803。为了处理端口，我们专门写了一个模块，用于管理端口的打开和关闭等。

## 12、Debug 

为了方便我们研发的控制而单独启的一个端口，相当于为我们开了一个后门。

## 13、gray 灰度

这个是DAL里面最出彩的一个技术点，但最后因为太复杂所以被抛弃。之后可能还会再用上。