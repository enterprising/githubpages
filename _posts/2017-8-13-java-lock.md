---
layout: post
title: 关于Java线程的锁
date: 2017-8-13 20:00
categories: Java
tags: [Java,同步异步,锁]
---

* content
{:toc} 
想到锁，脑袋里第一个出现的词汇是 synchronized（同步的）。但了解的其实不是很深，最近看到两篇不错的文章，然后翻了下书。决定仔细整理一下。

锁算是Java里面比较高级的东西了，同时也是最常用的一个点。必须要搞清楚。

# synchronized

翻译过来就是同步的，所谓同步，意思就是说被它修饰的方法或者代码块，一次只能被一个线程访问。

现实中的应用场景的话，火车买票、银行取钱，这些都是同步操作的。

实现这个锁的功能一般需要用到**synchronized**这个关键字，当然锁也不只有它一个可以实现。

两种用法：

- 放在方法名前面，形成同步方法
- 放在代码块前面，形成同步代码块

静态：锁定的是类

非静态：锁定的是对象

有一点要注意：对于synchronized方法或者synchronized代码块，当出现异常时，**JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。**

<br/>

# lock

**java.util.concurrent.locks**

Lock是并发包里面的一个接口，并不像synchronized那样是Java内置的关键字。

需要显示的指定起始位置和终止位置。一般使用 **ReentrantLock** 类作为锁。多个线程中必须要使用一个 **ReentrantLock** 类作为对象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示的指出。

而且，当出现异常的时候它不会像synchronized那样自动释放锁。所以很容易出现死锁，所以.. 需要在finally块中写 unlock()以防止出现死锁。

<br/>

# volatile

翻译成中文是：易变的，不稳定的。

也是Java的一个关键字。

一旦一个共享变量被volatile修饰之后，那么就有了两层语义：

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了每个变量的值，这新值对其它线程来说是立即可见的。
- 禁止进行指令重排序.. 这个不是很懂

保证了，原子性（和数据库的事务一样）、可见性（一个线程改了，其它线程都看得到） 和 有序性（即程序执行的顺序按照代码的先后顺序执行）

… 那它具体是怎么做到保证可见性和禁止指令重排序呢？

在《深入理解Java虚拟机》（没错，就是那本和我有故事的书）里面说到：

> “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个**lock前缀指令**”

那个Lock前缀指令实际上相当于一个内存屏障（也叫内存栅栏），它提供了三个功能。

- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的排到后面。
- 它会强制将对缓存的修改操作写入内存
- 如果是写操作，它会导致其他CPU中对应的缓存行无效。

<br/>

# synchronized和Lock的区别

- 前者是关键字，后者是接口
- 当出现异常的时候，前者自动释放锁，后者不会
- 使用前者时，等待的线程会一直等待下去，不能够响应中断。而后者可以让等待锁的线程响应中断
- 通过Lock可以知道有没有成功获取锁，但synchronized却无法办到
- Lock可以提高多线程进行读操作的 **效率**

<br/>

关于那些乱七八糟的锁：

# 可重入锁

如果锁具有可重入性，那么就能称为可重入锁。

哪些锁是可重入锁呢？像synchronized和ReentrantLock都是可重入锁。

可重入性是啥？其实只是锁的分配机制的问题，基于线程的分配，而不是基于方法调用的分配。

详细一点的话就是，当锁里面套着锁的时候，可重入，不需要再申请。

举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。

<br/>

# 可中断锁

就是可以响应中断的锁。

Lock是可以中断的锁，而synchronized不是。

如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。

<br/>

# 公平锁

看名字就知道是啥了吧.. 主要卖点在于“公平”。

尽量以请求锁的顺序来获取锁，这就是公平锁。不允许有插队这类的情况。

比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。

<br/>

# 非公平锁

跟上面那东西相反。

即，无法保证锁的获取是按照请求锁的顺序来进行的。这样就可能导致某个或者某些线程永远获取不到锁。

那有哪些是非公平锁呢？

synchronized就是最典型的一个，它无法保证等待的线程获取锁的顺序。

而Lock里面的ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。

<br/>

# 参考资料

1、[synchronized、Lock、volatile 差异分析](http://www.jianshu.com/p/dccad53a2665)

2、[深入研究 Java Synchronize 和 Lock 的区别与用法](http://blog.csdn.net/natian306/article/details/18504111)

3、 [java 同步锁(synchronized)](http://blog.csdn.net/lianqiangjava/article/details/12652201)